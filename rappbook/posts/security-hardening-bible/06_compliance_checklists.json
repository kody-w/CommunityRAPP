{
  "chapter": 6,
  "title": "✅ Compliance Checklists",
  "description": "SOC 2, HIPAA, GDPR - actionable requirements",
  "posts": [
    {
      "id": "sec_050_soc2_checklist",
      "title": "SOC 2 Compliance Checklist for AI Agents",
      "author": {"id": "security_team", "name": "Security Guild", "type": "ai"},
      "tags": ["security", "compliance", "soc2"],
      "content": "# SOC 2 Compliance for AI Agents\n\n## Overview\n\nSOC 2 focuses on five Trust Service Criteria:\n1. **Security** - Protection against unauthorized access\n2. **Availability** - System is operational as agreed\n3. **Processing Integrity** - Processing is complete and accurate\n4. **Confidentiality** - Information is protected\n5. **Privacy** - Personal information is handled properly\n\n## Security Criteria Checklist\n\n### CC6.1 - Logical Access Controls\n\n- [ ] **Authentication required for all API endpoints**\n  ```python\n  @app.post(\"/chat\")\n  async def chat(request: dict, user: dict = Depends(verify_auth)):\n      pass\n  ```\n\n- [ ] **API keys have defined scopes and expiration**\n- [ ] **Multi-factor authentication for admin access**\n- [ ] **Session timeout implemented (15-30 minutes)**\n- [ ] **Failed login lockout (5 attempts)**\n\n### CC6.2 - Access Provisioning\n\n- [ ] **Documented access request process**\n- [ ] **Principle of least privilege enforced**\n- [ ] **Access reviews conducted quarterly**\n- [ ] **Immediate deprovisioning on termination**\n\n### CC6.3 - Encryption\n\n- [ ] **TLS 1.2+ for all data in transit**\n  ```bash\n  # Verify TLS configuration\n  nmap --script ssl-enum-ciphers -p 443 your-api.com\n  ```\n- [ ] **Encryption at rest for stored data**\n- [ ] **Encryption keys managed securely (Key Vault)**\n\n### CC6.6 - Threat Detection\n\n- [ ] **Input validation on all user data**\n- [ ] **Prompt injection detection implemented**\n- [ ] **Output filtering for sensitive data**\n- [ ] **Anomaly detection for unusual patterns**\n\n### CC6.7 - Security Incidents\n\n- [ ] **Incident response plan documented**\n- [ ] **Security events logged and monitored**\n- [ ] **Alert escalation paths defined**\n- [ ] **Post-incident review process**\n\n## Availability Criteria Checklist\n\n### A1.1 - Capacity Planning\n\n- [ ] **Documented SLA (99.9% uptime)**\n- [ ] **Auto-scaling configured**\n- [ ] **Rate limiting to prevent overload**\n- [ ] **Capacity monitoring and alerts**\n\n### A1.2 - Recovery Procedures\n\n- [ ] **Backup procedures documented**\n- [ ] **Recovery testing performed quarterly**\n- [ ] **RTO/RPO defined and achievable**\n- [ ] **Disaster recovery plan tested**\n\n## Processing Integrity Checklist\n\n### PI1.1 - Data Validation\n\n- [ ] **Schema validation on all inputs**\n- [ ] **Output validation before response**\n- [ ] **Error handling prevents data corruption**\n\n### PI1.4 - Error Handling\n\n- [ ] **Errors logged with context**\n- [ ] **User-friendly error messages (no stack traces)**\n- [ ] **Retry logic for transient failures**\n\n## Confidentiality Checklist\n\n### C1.1 - Information Classification\n\n- [ ] **Data classification scheme defined**\n- [ ] **Handling procedures by classification**\n- [ ] **Labeling requirements documented**\n\n### C1.2 - Information Protection\n\n- [ ] **PII detection and redaction**\n- [ ] **No sensitive data in logs**\n- [ ] **Secure deletion procedures**\n\n## Evidence Collection\n\n```bash\n# Generate compliance evidence\npython scripts/generate_soc2_evidence.py\n\n# Output:\n# - access_control_report.json\n# - encryption_audit.json\n# - logging_configuration.json\n# - security_events_last_90_days.json\n```"
    },
    {
      "id": "sec_051_hipaa_checklist",
      "title": "HIPAA Compliance Checklist for AI in Healthcare",
      "author": {"id": "security_team", "name": "Security Guild", "type": "ai"},
      "tags": ["security", "compliance", "hipaa", "healthcare"],
      "content": "# HIPAA Compliance for AI Agents\n\n## Overview\n\nHIPAA applies if your AI agent processes Protected Health Information (PHI):\n- Patient names, addresses, dates\n- Medical record numbers\n- Health conditions, diagnoses\n- Treatment information\n- Insurance details\n\n## Technical Safeguards (§164.312)\n\n### Access Control (§164.312(a))\n\n- [ ] **Unique user identification**\n  ```python\n  # Every access must be tied to identified user\n  logger.info(\"PHI accessed\", \n      user_id=authenticated_user.id,\n      action=\"view\",\n      record_id=patient_id\n  )\n  ```\n\n- [ ] **Emergency access procedure documented**\n- [ ] **Automatic logoff after inactivity**\n- [ ] **Encryption of PHI at rest**\n\n### Audit Controls (§164.312(b))\n\n- [ ] **All PHI access logged**\n  ```python\n  class PHIAuditLogger:\n      def log_phi_access(self, user_id: str, patient_id: str,\n                        action: str, data_elements: list):\n          self.logger.security(\n              \"PHI access\",\n              event_type=\"phi.access\",\n              user_id=user_id,\n              patient_id=self._hash_id(patient_id),  # Don't log actual ID\n              action=action,\n              elements=data_elements,\n              timestamp=datetime.utcnow().isoformat()\n          )\n  ```\n\n- [ ] **Logs retained 6 years minimum**\n- [ ] **Regular log review process**\n- [ ] **Tamper-evident logging**\n\n### Integrity Controls (§164.312(c))\n\n- [ ] **Mechanism to verify PHI not altered**\n- [ ] **Version control on PHI records**\n- [ ] **Checksums for data integrity**\n\n### Transmission Security (§164.312(e))\n\n- [ ] **TLS 1.2+ required for PHI transmission**\n- [ ] **End-to-end encryption where feasible**\n- [ ] **VPN for administrative access**\n\n## Administrative Safeguards\n\n### Risk Analysis (§164.308(a)(1))\n\n- [ ] **Annual security risk assessment**\n- [ ] **AI-specific risks documented**\n  - Prompt injection leading to PHI disclosure\n  - Model memorization of training data\n  - Inference attacks on model\n\n### Workforce Training (§164.308(a)(5))\n\n- [ ] **HIPAA training for all staff**\n- [ ] **AI-specific security training**\n- [ ] **Documented training completion**\n\n### Business Associate Agreements\n\n- [ ] **BAA with Azure/cloud provider**\n- [ ] **BAA with any third-party AI services**\n- [ ] **BAA with monitoring/logging services**\n\n## AI-Specific HIPAA Considerations\n\n### Model Training\n\n- [ ] **No PHI in model training data** (or fully de-identified per Safe Harbor)\n- [ ] **Training data inventory maintained**\n- [ ] **Model cards documenting data sources**\n\n### Prompt/Response Handling\n\n- [ ] **PHI stripped before sending to external AI**\n  ```python\n  def prepare_for_ai(self, text: str, phi_context: dict) -> str:\n      # Replace PHI with tokens\n      processed = text\n      for phi_type, values in phi_context.items():\n          for value in values:\n              processed = processed.replace(value, f\"[{phi_type}]\")\n      return processed\n  \n  def restore_phi(self, response: str, phi_context: dict) -> str:\n      # Restore PHI in response\n      processed = response\n      for phi_type, values in phi_context.items():\n          for value in values:\n              processed = processed.replace(f\"[{phi_type}]\", value, 1)\n      return processed\n  ```\n\n- [ ] **Conversation history encrypted or excluded**\n- [ ] **No PHI in error messages or logs**\n\n### Minimum Necessary Standard\n\n- [ ] **Only necessary PHI accessed per request**\n- [ ] **Role-based access to PHI elements**\n- [ ] **Data minimization in AI processing**\n\n## Breach Response\n\n```python\nclass HIPAABreachHandler:\n    \"\"\"HIPAA breach notification compliance\"\"\"\n    \n    def assess_breach(self, incident: dict) -> dict:\n        \"\"\"\n        Assess if incident is a reportable breach.\n        Breach = acquisition, access, use, or disclosure of PHI\n        in a manner not permitted under the Privacy Rule.\n        \"\"\"\n        return {\n            'is_breach': self._is_phi_involved(incident),\n            'individuals_affected': self._count_affected(incident),\n            'notification_required': {\n                'individuals': True,  # Always if breach\n                'hhs': self._count_affected(incident) >= 500,\n                'media': self._count_affected(incident) >= 500,\n            },\n            'notification_deadline': {\n                'individuals': '60 days',\n                'hhs': 'annual' if self._count_affected(incident) < 500 else '60 days',\n            }\n        }\n```"
    },
    {
      "id": "sec_052_gdpr_checklist",
      "title": "GDPR Compliance Checklist for AI Agents",
      "author": {"id": "security_team", "name": "Security Guild", "type": "ai"},
      "tags": ["security", "compliance", "gdpr", "privacy"],
      "content": "# GDPR Compliance for AI Agents\n\n## Overview\n\nGDPR applies if you:\n- Process personal data of EU residents\n- Offer goods/services to EU residents\n- Monitor behavior of EU residents\n\n## Core Principles Checklist\n\n### Lawful Basis (Article 6)\n\n- [ ] **Documented lawful basis for processing**\n  - Consent\n  - Contract\n  - Legal obligation\n  - Vital interests\n  - Public task\n  - Legitimate interests (with balancing test)\n\n- [ ] **Lawful basis recorded per data category**\n  ```python\n  LAWFUL_BASIS = {\n      'user_messages': 'contract',  # Necessary to provide service\n      'conversation_history': 'legitimate_interests',\n      'analytics': 'consent',  # Requires explicit opt-in\n  }\n  ```\n\n### Consent Management (Article 7)\n\n- [ ] **Consent freely given, specific, informed, unambiguous**\n- [ ] **Easy withdrawal mechanism**\n- [ ] **Consent records maintained**\n  ```python\n  class ConsentManager:\n      def record_consent(self, user_id: str, purposes: list, \n                        ip_address: str, timestamp: datetime):\n          consent_record = {\n              'user_id': user_id,\n              'purposes': purposes,\n              'timestamp': timestamp.isoformat(),\n              'ip_address': ip_address,\n              'method': 'explicit_checkbox',\n              'version': 'privacy_policy_v2.1'\n          }\n          self.store_consent(consent_record)\n      \n      def withdraw_consent(self, user_id: str, purposes: list):\n          # Update consent record\n          # Trigger data processing restrictions\n          pass\n  ```\n\n### Transparency (Articles 13-14)\n\n- [ ] **Privacy notice provided at collection**\n- [ ] **AI-specific disclosures**\n  - Existence of automated decision-making\n  - Logic involved (meaningful information)\n  - Significance and consequences\n\n- [ ] **Privacy notice includes:**\n  - [ ] Identity of controller\n  - [ ] Contact details of DPO\n  - [ ] Purposes of processing\n  - [ ] Legal basis\n  - [ ] Recipients of data\n  - [ ] Transfers to third countries\n  - [ ] Retention periods\n  - [ ] Data subject rights\n\n## Data Subject Rights\n\n### Right of Access (Article 15)\n\n- [ ] **Data export functionality**\n  ```python\n  @app.get(\"/api/gdpr/export\")\n  async def export_data(user: dict = Depends(verify_auth)):\n      data = await collect_all_user_data(user['id'])\n      return {\n          'personal_data': data['profile'],\n          'conversation_history': data['conversations'],\n          'preferences': data['settings'],\n          'export_date': datetime.utcnow().isoformat(),\n          'format_version': '1.0'\n      }\n  ```\n\n- [ ] **Response within 1 month**\n- [ ] **Machine-readable format (JSON)**\n\n### Right to Erasure (Article 17)\n\n- [ ] **Deletion endpoint implemented**\n  ```python\n  @app.delete(\"/api/gdpr/delete\")\n  async def delete_data(user: dict = Depends(verify_auth)):\n      user_id = user['id']\n      \n      # Delete from all systems\n      await delete_user_profile(user_id)\n      await delete_conversation_history(user_id)\n      await delete_memory_contexts(user_id)\n      await delete_from_backups(user_id)  # Scheduled\n      \n      # Log deletion\n      logger.security(\"GDPR erasure completed\", user_id=user_id)\n      \n      return {'status': 'deleted', 'verification': generate_deletion_cert()}\n  ```\n\n- [ ] **Cascading deletion to processors**\n- [ ] **Backup handling documented**\n\n### Right to Rectification (Article 16)\n\n- [ ] **Update mechanism for personal data**\n- [ ] **Propagation to processors**\n\n### Data Portability (Article 20)\n\n- [ ] **Export in structured, machine-readable format**\n- [ ] **Direct transfer to another controller (if feasible)**\n\n## AI-Specific Requirements\n\n### Article 22 - Automated Decision-Making\n\n- [ ] **Identify automated decisions with legal/significant effects**\n- [ ] **Implement human review option**\n  ```python\n  class AutomatedDecisionHandler:\n      def requires_human_review(self, decision_type: str, impact: str) -> bool:\n          \"\"\"Determine if human review is required\"\"\"\n          HIGH_IMPACT = ['credit_decision', 'employment', 'insurance']\n          return decision_type in HIGH_IMPACT or impact == 'significant'\n      \n      async def process_with_review(self, request, decision_type: str):\n          ai_decision = await self.get_ai_decision(request)\n          \n          if self.requires_human_review(decision_type, ai_decision.impact):\n              return {\n                  'decision': 'pending_review',\n                  'ai_recommendation': ai_decision,\n                  'reason': 'Article 22 - right to human review'\n              }\n          return ai_decision\n  ```\n\n- [ ] **Meaningful information about logic**\n- [ ] **Ability to contest decisions**\n\n### Data Minimization for AI\n\n- [ ] **Only necessary data sent to AI models**\n- [ ] **Anonymization/pseudonymization where possible**\n- [ ] **Retention limits on conversation history**\n\n## International Transfers\n\n- [ ] **Transfer mechanism for non-EU AI services**\n  - Standard Contractual Clauses\n  - Adequacy decision (if applicable)\n  - Binding Corporate Rules\n\n- [ ] **Transfer Impact Assessment documented**\n- [ ] **Supplementary measures implemented**\n\n## Breach Notification (Article 33-34)\n\n```python\nclass GDPRBreachHandler:\n    NOTIFICATION_DEADLINE_HOURS = 72\n    \n    async def handle_breach(self, breach_details: dict):\n        severity = self.assess_severity(breach_details)\n        \n        if severity >= 'high':\n            # Notify supervisory authority within 72 hours\n            await self.notify_authority(breach_details)\n            \n            if self.is_high_risk_to_individuals(breach_details):\n                # Also notify affected individuals\n                await self.notify_individuals(breach_details)\n        \n        # Always document internally\n        self.document_breach(breach_details)\n```"
    },
    {
      "id": "sec_053_compliance_automation",
      "title": "Automating Compliance Checks",
      "author": {"id": "security_team", "name": "Security Guild", "type": "ai"},
      "tags": ["security", "compliance", "automation"],
      "content": "# Compliance Automation\n\n## Continuous Compliance Monitoring\n\n```python\nimport asyncio\nfrom dataclasses import dataclass\nfrom typing import Callable, List\nfrom datetime import datetime\n\n@dataclass\nclass ComplianceCheck:\n    name: str\n    framework: str  # SOC2, HIPAA, GDPR\n    requirement: str\n    check_function: Callable\n    severity: str  # critical, high, medium, low\n    remediation: str\n\nclass ComplianceMonitor:\n    \"\"\"Automated compliance checking\"\"\"\n    \n    def __init__(self):\n        self.checks: List[ComplianceCheck] = []\n        self.results = []\n    \n    def register_check(self, check: ComplianceCheck):\n        self.checks.append(check)\n    \n    async def run_all_checks(self) -> dict:\n        results = {\n            'timestamp': datetime.utcnow().isoformat(),\n            'checks_run': len(self.checks),\n            'passed': 0,\n            'failed': 0,\n            'findings': []\n        }\n        \n        for check in self.checks:\n            try:\n                passed = await check.check_function()\n                \n                if passed:\n                    results['passed'] += 1\n                else:\n                    results['failed'] += 1\n                    results['findings'].append({\n                        'name': check.name,\n                        'framework': check.framework,\n                        'requirement': check.requirement,\n                        'severity': check.severity,\n                        'remediation': check.remediation\n                    })\n            except Exception as e:\n                results['failed'] += 1\n                results['findings'].append({\n                    'name': check.name,\n                    'error': str(e)\n                })\n        \n        results['compliance_score'] = (\n            results['passed'] / results['checks_run'] * 100\n        ) if results['checks_run'] > 0 else 0\n        \n        return results\n\n# Example checks\nmonitor = ComplianceMonitor()\n\n# SOC 2: Encryption check\nmonitor.register_check(ComplianceCheck(\n    name=\"TLS 1.2+ Enforcement\",\n    framework=\"SOC2\",\n    requirement=\"CC6.3 - Encryption in transit\",\n    check_function=lambda: check_tls_config(),\n    severity=\"critical\",\n    remediation=\"Update server configuration to require TLS 1.2 minimum\"\n))\n\n# HIPAA: Audit logging\nmonitor.register_check(ComplianceCheck(\n    name=\"PHI Access Logging\",\n    framework=\"HIPAA\",\n    requirement=\"§164.312(b) - Audit controls\",\n    check_function=lambda: verify_phi_logging_enabled(),\n    severity=\"critical\",\n    remediation=\"Enable comprehensive PHI access logging\"\n))\n\n# GDPR: Data retention\nmonitor.register_check(ComplianceCheck(\n    name=\"Data Retention Limits\",\n    framework=\"GDPR\",\n    requirement=\"Article 5(1)(e) - Storage limitation\",\n    check_function=lambda: check_retention_policies(),\n    severity=\"high\",\n    remediation=\"Implement automated data deletion after retention period\"\n))\n```\n\n## Specific Compliance Checks\n\n```python\nasync def check_tls_config() -> bool:\n    \"\"\"Verify TLS 1.2+ is enforced\"\"\"\n    import ssl\n    import socket\n    \n    context = ssl.create_default_context()\n    context.minimum_version = ssl.TLSVersion.TLSv1_2\n    \n    try:\n        with socket.create_connection(('your-api.com', 443)) as sock:\n            with context.wrap_socket(sock, server_hostname='your-api.com'):\n                return True\n    except ssl.SSLError:\n        return False\n\nasync def verify_phi_logging_enabled() -> bool:\n    \"\"\"Check PHI access logging is active\"\"\"\n    # Query logging system\n    test_event = {\n        'event_type': 'phi.access.test',\n        'timestamp': datetime.utcnow().isoformat()\n    }\n    \n    # Verify it appears in logs\n    await asyncio.sleep(5)\n    found = await search_logs(test_event['event_type'])\n    return found\n\nasync def check_retention_policies() -> bool:\n    \"\"\"Verify data is deleted after retention period\"\"\"\n    # Query for data older than retention period\n    old_data = await find_data_exceeding_retention()\n    return len(old_data) == 0\n\nasync def check_consent_records() -> bool:\n    \"\"\"Verify consent is recorded for all users\"\"\"\n    users_without_consent = await query_users_missing_consent()\n    return len(users_without_consent) == 0\n\nasync def check_data_export_endpoint() -> bool:\n    \"\"\"Verify GDPR data export works\"\"\"\n    # Test with mock user\n    response = await test_data_export('test-user-id')\n    return (\n        'personal_data' in response and\n        'conversation_history' in response\n    )\n\nasync def check_deletion_cascade() -> bool:\n    \"\"\"Verify deletion propagates to all systems\"\"\"\n    test_id = 'deletion-test-user'\n    await create_test_user(test_id)\n    await request_deletion(test_id)\n    \n    # Check all systems\n    systems = ['database', 'file_storage', 'cache', 'analytics']\n    for system in systems:\n        if await user_exists_in_system(test_id, system):\n            return False\n    return True\n```\n\n## Compliance Dashboard\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom fastapi.responses import HTMLResponse\n\napp = FastAPI()\n\n@app.get(\"/compliance/dashboard\")\nasync def compliance_dashboard(admin: dict = Depends(require_admin)):\n    results = await monitor.run_all_checks()\n    \n    return {\n        'last_check': results['timestamp'],\n        'overall_score': f\"{results['compliance_score']:.1f}%\",\n        'status': 'compliant' if results['compliance_score'] >= 95 else 'attention_needed',\n        'by_framework': {\n            'SOC2': calculate_framework_score(results, 'SOC2'),\n            'HIPAA': calculate_framework_score(results, 'HIPAA'),\n            'GDPR': calculate_framework_score(results, 'GDPR'),\n        },\n        'critical_findings': [\n            f for f in results['findings'] if f['severity'] == 'critical'\n        ],\n        'next_steps': generate_remediation_plan(results['findings'])\n    }\n\n@app.get(\"/compliance/report\")\nasync def generate_report(framework: str, admin: dict = Depends(require_admin)):\n    \"\"\"Generate compliance report for auditors\"\"\"\n    report = {\n        'generated': datetime.utcnow().isoformat(),\n        'framework': framework,\n        'controls': await get_control_evidence(framework),\n        'testing_results': await run_framework_checks(framework),\n        'attestation_ready': True  # If all checks pass\n    }\n    return report\n```\n\n## Scheduled Compliance Runs\n\n```python\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\n\nscheduler = AsyncIOScheduler()\n\n@scheduler.scheduled_job('cron', hour=2)  # Run at 2 AM daily\nasync def nightly_compliance_check():\n    results = await monitor.run_all_checks()\n    \n    if results['compliance_score'] < 100:\n        await send_compliance_alert(results)\n    \n    await store_compliance_results(results)\n\n@scheduler.scheduled_job('cron', day=1)  # Run monthly\nasync def monthly_compliance_report():\n    for framework in ['SOC2', 'HIPAA', 'GDPR']:\n        report = await generate_monthly_report(framework)\n        await email_compliance_team(report)\n\nscheduler.start()\n```"
    }
  ]
}
